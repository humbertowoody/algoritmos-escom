<!DOCTYPE html>
<html>
  <head>
    <!-- Metadatos de ajuste de cliente web -->
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Multiplicaci√≥n de Matrices de Strassen</title>

    <!-- Secci√≥n de metadatos -->
    <meta
      name="description"
      content="P√°gina que explica el uso y funcionamiento del Algoritmo de Multicplicaci√≥n de Matrices de Strassen"
    />
    <meta
      name="author"
      content="Santos M√©ndez Ulises Jes√∫s, Vallejo Garc√≠a Alan Gerardo, Ortega Alcocer Humberto Alejandro"
    />

    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <!-- Estilos para la p√°gina -->
    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="assets/css/tema-escom.css" />

    <!-- Tema para resaltar el c√≥digo -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section id="inicio">
          <!-- Secci√≥n para la presentaci√≥n del equipo y proyecto -->
          <section id="portada">
            <img src="assets/img/logo-escom.png" alt="ESCOM" style="max-height: 130px;">
            <img src="assets/img/logo-ipn.webp" alt="IPN" style="max-height: 130px;">
            <h3>Multiplicaci√≥n de Matrices de Strassen</h3>
            <hr />
            <p>Optimizaciones gal√°cticas.</p>
            <p>
              <small
                >Escuela Superior de C√≥mputo del Instituto Polit√©cnico
                Nacional</small
              >
            </p>
          </section>
          <section id="equipo">
            <h3>S√∫per Equipo ü¶∏üèª‚Äç‚ôÇÔ∏è</h3>
            <p>
              <ul>
                <li>Alan Gerardo Vallejo Garc√≠a.</li>
                <li>Ulises Jes√∫s Santos M√©ndez.</li>
                <li>Humberto Alejandro Ortega Alcocer.</li>
              </ul>
            </p>
            <hr>
            <p>An√°lisis de Algoritmos | 3CM14</p>
            <p></p>
            <small
              >M. Edgardo Adri√°n Franco Mart√≠nez.</small
            >
            <p>üëâ</p>
          </section>
        </section>
        <section id="indice">
          <h3>√çndice</h3>
          <ul>
            <li>Matrices, un vistazo hist√≥rico.</li>
            <li>Multiplicar matrices (fuerza bruta).</li>
            <li>Divide y Vencer√°s.</li>
            <li>Optimizaci√≥n de Strassen.</li>
            <li>Bibliograf√≠a</li>
          </ul>
          <p>üëâ</p>
        </section>
        <section id="historia">
          <!-- Secci√≥n para la historia y antecedentes -->
          <section id="historia-intro">
            <h3>Matrices, un vistazo hist√≥rico.</h3>
            <p>üëá</p>
          </section>
          <section id="historia-origen">
            <h3>¬øDe d√≥nde vienen las matrices?</h3>
            <p>
              Las matrices tienen muchos a√±os de existir y ser analizadas,
               los <b>cuadros m√°gicos</b> y <b>cuadros latinos</b> datan (seg√∫n la literatura china) del <b>650 a.C.</b>
            </p>
            <img src="assets/img/matriz.gif" alt="Matriz">
          </section>
          <section id="historia-personalidades">
            <p>Algunas personalidades que han contribu√≠do al estudio de matrices:</p>
            <p>
              <b>Jiu Zhang Suan Shu</b>, 
              <b>Seki K≈çwa</b>, 
              <b>Gottfried Leibniz</b>, 
              <b>Cramer</b>, 
              <b>Gauss</b>, 
              <b>Willhelm Jordan</b>, 
              <b>Hamilton</b>, 
              <b>Von Neumann</b>, 
              <b>Frobenius</b> y
              <b>Heisenberg</b>.
            </p>
          </section>
          <section id="historia-operaciones">
            <h3>Operaciones con matrices</h3>
            <p>
              Las matrices cuentan con <b>todas las operaciones</b> definidas por el √°lgebra matricial,
              es decir, podemos realizar:
            </p>
            <ul>
              <li>Suma.</li>
              <li>Diferencia.</li>
              <li><b>Producto</b>, <em>(la operaci√≥n crucial de este algoritmo)</em>.</li>
              <li>Cociente.</li>
              <li>etc√©tera...</li>
            </ul>
            <p>üëâ</p>
          </section>
        </section>
        <section id="fuerza-bruta">
          <!-- Secci√≥n para hablar de la fuerza bruta y optimizaciones-->
          <section id="fuerza-bruta-inicio">
            <h3>Multiplicar Matrices</h3>
            <p>Algoritmo <em>directo</em> o por <em>fuerza bruta</em>.</p>
            <p>üëá</p>
          </section>
          <section id="fuerza-bruta-definicion">
            En la <b>multiplicaci√≥n de matrices</b>, cada entrada en la matriz producto es el producto punto de un rengl√≥n en la primera matriz por una columna en la segunda matriz.
          </section>
          <section id="fuerza-bruta-procedimiento">
            <p>
              Procedimiento de la operaci√≥n.
            </p>
            <video data-autoplay src="assets/video/multiplicacion-matrices.mp4"></video>
          </section>
          <section id="fuerza-bruta-pseudocodigo">
            La operaci√≥n de <em>multiplicaci√≥n</em> se puede encapsular en el siguiente pseudoc√≥digo:
            <pre><code class="hljs" data-trim data-line-numbers data-no-escape>
              procedimiento multiplicar_matrices(A,B)
                entrada A,B, matrices de n*n
                salida C, matriz de n*n
              inicio
                para i = 0, hasta n-1, incrementando en 1
                  para j = 0, hasta n-1, incrementando en 1
                    C[i,j] = 0; // inicializamos matriz resultante en 0.
                  fin para
                fin para

                para i = 0, hasta n-1, incrementando en 1
                  para j = 0, hasta n-1, incrementando en 1
                    para k = 0, hasta n-1, incrementando en 1
                      C[i,j] = C[i,j] + A[i,k] * B[k,j] // producto matricial.
                    fin para
                  fin para
                fin para
              fin multiplicar_matrices
            </code></pre>
          </section>
          <section id="fuerza-bruta-analisis-complejidad">
            <p>
              Aqu√≠, ser√° f√°cil obtener el orden de la complejidad temporal de nuestro algoritmo ya que
              tenemos tres ciclos anidados de orden lineal. Lo cual resulta en:
            </p>
            <p>\[O(n*n*n) = O(n^3)\]</p>
            <pre><code class="hljs" data-trim data-line-numbers data-no-escape data-ln-start-from="11">
                para i = 0, hasta n-1, incrementando en 1
                  para j = 0, hasta n-1, incrementando en 1
                    para k = 0, hasta n-1, incrementando en 1
                      C[i,j] = C[i,j] + A[i,k] * B[k,j] // producto matricial.
                    fin para
                  fin para
                fin para
            </code></pre>
          </section>
          <section id="fuerza-bruta-codigo">
            Realizando la implementaci√≥n del algoritmo <em>de fuerza bruta o directo</em> en
            JavaScript, tendr√≠amos el siguiente c√≥digo:
            <pre><code class="hljs" data-trim data-line-numbers data-no-escape>
              function multiplicar_matrices(a, b) {
                let numFilasA = a.length, numColsA = a[0].length,
                    numColsB = b[0].length,
                    m = new Array(numFilasA);
                for (var fila = 0; fila < numFilasA; ++fila) {
                  m[fila] = new Array(numColsB); // crear fila
                  for (var columna = 0; columna < numColsB; ++columna) {
                    m[fila][columna] = 0; // inicializar celda
                    for (var i = 0; i < numColsA; ++i) {
                      m[fila][columna] += a[fila][i] * b[i][columna];
                    }
                  }
                }
                return m;
              }
            </code></pre>
          </section>
          <section id="fuerza-bruta-animacion">
            <p>
              Prueba a introducir los valores que quieras, o utiliza los aleatorios, para probar
              c√≥mo se ver√≠an las operaciones paso a paso de este algoritmo:
            </p>
            <iframe data-src="animacion-fb.html" class="animacion-incrustada"></iframe>
            <p>üëâ</p>
          </section>
        </section>
        <section id="divide-y-venceras">
          <!-- Secci√≥n para hablar de la propuesta con Divide y Vencer√°s -->
          <section id="divide-y-venceras-inicio">
            <h3>Divide y Vencer√°s</h3>
            <p>¬øC√≥mo atacar nuestro problema de forma que podamos simplificarlo?</p>
            <p>üëá</p>
          </section>
          <section id="divide-y-venceras-definicion">
            <p>
              Divide y Vencer√°s es un paradigma de resoluci√≥n de problemas que se basa en
              tomar un problema grande y <b>descomponerlo en problemas m√°s peque√±os</b> d√≥nde la
              soluci√≥n inmediata es evidente, o al menos m√°s de lo que ser√≠a para el problema
              inicial.
            </p>
            <img src="assets/img/divide-y-venceras.gif" alt="Divide y Vencer√°s" style="max-height: 25vh;">
          </section>
          <section id="divide-y-venceras-enfoque-general">
            <p>
              En su forma m√°s general, un algoritmo <em>divide y vencer√°s</em> consiste
              en tres pasos simples:
            </p>
            <ol>
              <li>Separar el problema en sub-problemas hasta llegar a su forma m√°s simple.</li>
              <li>Resolver los problemas <em>simplificados</em>.</li>
              <li>Combinar las soluciones parciales de vuelta en la soluci√≥n general.</li>
            </ol>
            
          </section>
          <section id="divide-y-venceras-aplicacion">
            Aplic√°ndolo a la <em>multiplicaci√≥n de matrices</em>, lo primero que analizaremos
            ser√°n las <b>dimensiones</b> de una matriz.
            \[m \times n\]
            La <b>multiplicaci√≥n</b> tiene la restricci√≥n de que el <em>n√∫mero de filas</em>
            de la primer matriz debe ser el <em>n√∫mero de columnas</em> de la segunda matriz.
          </section>
          <section id="divide-y-venceras-dividir">
            <h3>Dividiendo</h3>
            <p>
              Sabiendo eso, nuestro primer paso ser√° tratar de, recursivamente, dividir nuestras
              matrices iniciales en sub-matrices hasta llegar a un caso base de matrices:
            </p>
            \[m \times n = 2 \times 2\]
          </section>
          <section id="divide-y-venceras-caso-base">
            <h3>Caso Base</h3>
            <p>
              Llegado al caso base (matrices de 2x2), entonces realizaremos
              las operaciones pertinentes para obtener el producto, de la siguiente manera:
            </p>
            <img src="assets/img/multiplicar-matrices.png" alt="Multiplicaci√≥n de Matrices">
          </section>
          <section id="divide-y-venceras-reensamble">
            <h3>Reensamblado</h3>
            <p>
              Para <em>reensamblar</em> los resultados parciales de nuestra recursividad,
              realizaremos el producto de los resultados.
            </p>
            <img src="assets/img/reensamble-matrices-dv.png" alt="Reensamblado de Matrices" style="max-height: 40vh;">
          </section>
          <section id="divide-y-venceras-pseudocodigo">
            Pseudoc√≥digo de <em>divide y vencer√°s</em>:
            <pre><code class="hljs" data-trim data-line-numbers data-no-escape>
              procedimiento multiplicar_matrices_dv(A,B)
                si A.columnas = 1, entonces // caso base
                  regresa C[0,0] = A[0,0] * B[0,0]
                fin si
                // recursividad
                ae = multiplicar_matrices_dv(A/4[0], B/4[0]) // 1
                bg = multiplicar_matrices_dv(A/4[1], B/4[2]) // 2
                af = multiplicar_matrices_dv(A/4[0], B/4[1]) // 3
                bh = multiplicar_matrices_dv(A/4[1], B/4[3]) // 4
                ce = multiplicar_matrices_dv(A/4[2], B/4[0]) // 5
                dg = multiplicar_matrices_dv(A/4[3], B/4[2]) // 6
                cf = multiplicar_matrices_dv(A/4[2], B/4[1]) // 7
                dh = multiplicar_matrices_dv(A/4[3], B/4[3]) // 8
                C[0,0] = ae + bg // La suma en caso base ser√° O(n^2) para
                C[0,1] = af + bh // matrices de dimensiones mayor a dos.
                C[1,0] = ce + dg
                C[1,1] = cf + dh
                regresa C
              fin multiplicar_matrices_dv
            </code></pre>
          </section>
          <section id="divide-y-venceras-complejidad">
            <p>
              Las llamadas recursivas del c√≥digo anterior, mediante un an√°lisis de <em>Teorema Maestro</em>
              nos llevan a la conclusi√≥n de que nuestro algoritmo tiene una complejidad de:
            </p>
            \[T(n) = 8T(n/2) + O(n^2) = O(n^{log_2{(8)}}) = O(n^3)\]
            <p>As√≠, nuestra complejidad realmente no se vi√≥ reducida.</p>
          </section>
          <section>
            A continuaci√≥n podr√°s introducir dos matrices con valores enteros positivos y ver el paso a
            paso del procedimiento en divide y vencer√°s.
          </section>
          <section id="divide-y-venceras-animacion" data-background-iframe="animacion-dv.html" data-background-interactive></section>
        </section>
        <section id="strassen">
          <!-- Secci√≥n para hablar de Strassen puntualmente -->
          <section id="strassen-inicio">
            <h3>Optimizaci√≥n de Strassen</h3>
            <p>M√°s all√° de <em>divide y vencer√°s</em>, para datos <b>gal√°cticos</b>.</p>
            <p>üëá</p>
          </section>
          <section id="strassen-biografia">
            <img src="assets/img/volker-strassen.jpeg" alt="Volker Strassen" style="max-height: 200px;">
            <p>
              <b>Volker Strassen</b> es un matem√°tico Alem√°n nacido en 1936, ha recibido
              m√∫ltiples premios y distinciones gracias al descubrimiento del <em>algoritmo
              de multiplicaci√≥n de matrices m√°s r√°pido</em>, multiplicaci√≥n de n√∫meros grandes
              y determinaci√≥n probabil√≠stica de n√∫meros primos (entre otros).
            </p>
          </section>
          <section id="strassen-historia">
            <h3>Multiplicaci√≥n de Matrices de Strassen</h3>
            <p>
              En 1969, <b>Volker Strassen</b> public√≥ el algoritmo de multiplicaci√≥n de matrices
              de nombre propio con el que demostr√≥ que se pueden hayar mejores resultados a√∫n 
              en situaciones d√≥nde es com√∫n dejar de buscar mejores caminos.
            </p>
          </section>
          <section id="strassen-complejidad">
            <p>
              Como vimos anteriormente en el an√°lisis <em>divide y vencer√°s</em>, se requieren 8 pasos
              recursivos para realizar los c√°lculos necesarios. <b>Strassen</b> demostr√≥ que es posible
              realizar √∫nicamente <b>7 pasos recursivos</b>, mejorando as√≠ la complejidad de:
            </p>
            \[O(n^{log_2{(8)}}) = O(n^3)\]
            <p>a una <em>poco menos</em> elevada de:</p>
            \[O(n^{log_2{(7)}}) \approx O(n^{2.807})\]
          </section>
          <section id="strassen-galactico">
            <p>
              Cuando un algoritmo ser√° eficaz para valores de n <em>muy</em> grandes, se le denomina
              <b>algoritmo gal√°ctico</b>. El algoritmo de <em>Strassen</em> es considerado uno de ellos
              ya que su aplicaci√≥n es √∫til para <em>datasets</em> de dimensiones enormes.
            </p>
            <img src="assets/img/comparativa-strassen.png" alt="Comparativa entre complejidades" style="max-height: 40vh; border: 1px solid black; border-radius: 10px;">
          </section>
          <section id="strassen-operaciones">
            <p>Considerando las matrices:</p>
            <img src="assets/img/ops-strassen-1.gif" alt="Matrices de Operaciones Strassen">
            <p>
              Las operaciones en cuesti√≥n son:
            </p>
            <img src="assets/img/ops-strassen.gif" alt="Operaciones Strassen">
          </section>
          <section id="strassen-aplicaciones">
            <p>
              Existen muchas √°reas d√≥nde la multiplicaci√≥n de matrices es utilizada, sin embargo, para que 
              el algoritmo de <em>Strassen</em> merezca la pena de ser usado, vimos que ser√° en matrices <em>muy</em>
              grandes, por lo que su uso actual reside principalmente en:
            </p>
            <ul>
              <li>M√°scaras para manipulaci√≥n de im√°genes.</li>
              <li>Transformaciones de objetos en 2 y 3 dimensiones.</li>
              <li>Cambios de perspectivas con matrices de transformaciones.</li>
            </ul>
          </section>
          <section id="strassen-pseudocodigo">
            Pseudoc√≥digo del algoritmo de <em>Strassen</em>:
            <pre><code class="hljs" data-trim data-line-numbers data-no-escape>
              STRASSEN(A, B)
                n = A.filas
                si n = 1, entonces
                    return a[1, 1] * b[1, 1]
                fin si
                declara C matriz de n x n
                A[1, 1] = A[1..n / 2][1..n / 2]
                A[1, 2] = A[1..n / 2][n / 2 + 1..n]
                A[2, 1] = A[n / 2 + 1..n][1..n / 2]
                A[2, 2] = A[n / 2 + 1..n][n / 2 + 1..n]
                B[1, 1] = B[1..n / 2][1..n / 2]
                B[1, 2] = B[1..n / 2][n / 2 + 1..n]
                B[2, 1] = B[n / 2 + 1..n][1..n / 2]
                B[2, 2] = B[n / 2 + 1..n][n / 2 + 1..n]
                S[1] = B[1, 2] - B[2, 2]
                S[2] = A[1, 1] + A[1, 2]
                S[3] = A[2, 1] + A[2, 2]
                S[4] = B[2, 1] - B[1, 1]
                S[5] = A[1, 1] + A[2, 2]
                S[6] = B[1, 1] + B[2, 2]
                S[7] = A[1, 2] - A[2, 2]
                S[8] = B[2, 1] + B[2, 2]
                S[9] = A[1, 1] - A[2, 1]
                S[10] = B[1, 1] + B[1, 2]
                P[1] = STRASSEN(A[1, 1], S[1])
                P[2] = STRASSEN(S[2], B[2, 2])
                P[3] = STRASSEN(S[3], B[1, 1])
                P[4] = STRASSEN(A[2, 2], S[4])
                P[5] = STRASSEN(S[5], S[6])
                P[6] = STRASSEN(S[7], S[8])
                P[7] = STRASSEN(S[9], S[10])
                C[1..n / 2][1..n / 2] = P[5] + P[4] - P[2] + P[6]
                C[1..n / 2][n / 2 + 1..n] = P[1] + P[2]
                C[n / 2 + 1..n][1..n / 2] = P[3] + P[4]
                C[n / 2 + 1..n][n / 2 + 1..n] = P[5] + P[1] - P[3] - P[7]
                regresa C
            </code></pre>
          </section>
          <section id="strassen-animacion" data-background-iframe="animacion-strassen.html" data-background-interactive></section>
        </section>
        <section id="bibliografia-y-creditos">
          <section id="bibliografia">
            <h3>Bibliograf√≠a</h3>
            <ul>
              <li>Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2009). Introduction to algorithms (3.a ed.). The MIT Press.</li>
              <li>Penttonen, M. (1978). Complejidad de los algoritmos. En Complejidad de los algoritmos (pp. 15‚Äì25). Universidad de Madrid.</li>
            </ul>
          </section>
          <section id="creditos-tecnicos">
            <h3>Librer√≠as y recursos</h3>
            <ul>
              <li><b>RevealJS</b>: para el formato de presentaci√≥n del sitio.</li>
              <li><b>Google Fonts</b>: para las tipograf√≠as empleadas.</li>
              <li><b>jQuery</b>: para las animaciones.</li>
            </ul>
          </section>
        </section>
        <section id="fin">
          <h3>¬°Eso es todo!</h3>
          <p>Puedes usar las flechas para regresar a la parte que m√°s te haya gustado, tambi√©n puedes <a href="#">hacer click aqu√≠ para volver al inicio</a>.</p>
          <img src="assets/img/logo-escom.png" alt="ESCOM" style="max-height: 130px;">
          <img src="assets/img/logo-ipn.webp" alt="IPN" style="max-height: 130px;">
        </section>
      </div>
    </div>

    <!-- Scripts para la p√°gina  -->
    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
      // Inicializamos Reveal.js el cual gestiona los "slides" de nuestra presentaci√≥n.
      Reveal.initialize({
        hash: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],
      });
    </script>
  </body>
</html>
